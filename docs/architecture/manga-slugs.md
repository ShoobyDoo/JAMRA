# Manga Slug Architecture

## Problem Statement

Currently, manga are identified by obfuscated IDs generated by sources (e.g., `/manga/01J76XY7E9FNDZ1DBBM6PBJPFK` for One Piece). This creates poor UX with non-human-readable URLs.

**Goal**: Use human-readable slugs like `/manga/one-piece` while maintaining data integrity and backward compatibility.

## Proposed Solution

### 1. Extension Layer Changes

**File**: `packages/weebcentral-extension/src/scraper.ts`

The extension must provide BOTH a stable ID and a human-readable slug:

```typescript
interface SeriesMetadata {
  id: string;           // Stable, unique ID (01J76XY7E9FNDZ1DBBM6PBJPFK)
  name: string;         // URL-friendly slug (one-piece)
  displayTitle: string; // Human-readable title (One Piece)
}
```

**Implementation**:
- Extract series name from WeebCentral URLs: `/series/{id}/{name}` â†’ use `name` as slug
- Slug generation rules:
  - Lowercase
  - Replace spaces with hyphens
  - Remove special characters except hyphens
  - Already done by WeebCentral (verify consistency)

**Changes Required**:
```typescript
// In searchManga()
items.push({
  id,                    // Keep stable ID
  slug: name,            // Add slug field
  title,
  coverUrl,
});

// In getMangaDetails()
return {
  id: mangaId,          // Keep stable ID
  slug: metadata.name,  // Add slug field
  title,
  // ... rest of fields
};
```

### 2. SDK Changes

**File**: `packages/extension-sdk/src/types.ts`

Add `slug` field to interfaces:

```typescript
export interface MangaSummary {
  id: string;         // Stable unique ID
  slug?: string;      // URL-friendly slug (optional for backward compat)
  title: string;
  // ... existing fields
}

export interface MangaDetails extends MangaSummary {
  // Inherits slug from MangaSummary
  // ... existing fields
}
```

### 3. Database Changes

**File**: `packages/catalog-db/src/migrations.ts`

Add migration #8 to add slug column:

```typescript
{
  id: 8,
  up: (db) => {
    // Add slug column to manga table
    const columns = db.prepare(`PRAGMA table_info(manga)`).all();
    const existing = new Set(columns.map((column) => column.name));

    if (!existing.has("slug")) {
      db.exec(`ALTER TABLE manga ADD COLUMN slug TEXT;`);
    }

    // Create unique index for slug lookups
    db.exec(`
      CREATE UNIQUE INDEX IF NOT EXISTS idx_manga_slug
        ON manga (slug) WHERE slug IS NOT NULL;
    `);

    // Backfill existing entries from series_name if available
    db.exec(`
      UPDATE manga
      SET slug = series_name
      WHERE series_name IS NOT NULL AND slug IS NULL;
    `);
  },
}
```

**File**: `packages/catalog-db/src/catalogRepository.ts`

Add slug support to repository methods:

```typescript
upsertMangaSummaries(
  extensionId: string,
  items: MangaSummary[],
  seriesNames?: Map<string, string>
): void {
  const stmt = this.db.prepare(`
    INSERT INTO manga (
      id, extension_id, title, slug, series_name, ...
    ) VALUES (@id, @extension_id, @title, @slug, @series_name, ...)
    ON CONFLICT(id) DO UPDATE SET
      slug = COALESCE(excluded.slug, manga.slug),
      ...
  `);

  // Map items with slug
  for (const item of items) {
    stmt.run({
      id: item.id,
      slug: item.slug ?? seriesNames?.get(item.id) ?? null,
      ...
    });
  }
}

// New method for slug-based lookups
getMangaBySlug(slug: string): MangaRow | undefined {
  return this.db
    .prepare(`SELECT * FROM manga WHERE slug = @slug LIMIT 1`)
    .get({ slug });
}
```

### 4. API Layer Changes

**File**: `packages/catalog-server/src/server.ts`

Update manga details endpoint to support both ID and slug:

```typescript
// New endpoint: GET /api/manga/by-slug/:slug
app.get("/api/manga/by-slug/:slug", async (req, res) => {
  const { slug } = req.params;

  // Try to find by slug first
  const mangaRow = repository?.getMangaBySlug(slug);
  if (!mangaRow) {
    return res.status(404).json({ error: "Manga not found" });
  }

  // Fetch full details using the ID
  const { details } = await service.syncManga(
    mangaRow.extension_id,
    mangaRow.id
  );

  res.json({ details });
});

// Keep existing /api/manga/:id for backward compatibility
```

### 5. Frontend Changes

**File**: `src/lib/api.ts`

Add slug-based fetch function:

```typescript
export async function fetchMangaBySlug(slug: string) {
  const response = await fetch(`${API_BASE_URL}/api/manga/by-slug/${slug}`);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);
  return response.json();
}

// Update existing function to try slug first, fall back to ID
export async function fetchMangaDetails(slugOrId: string) {
  // If it looks like a slug (lowercase, hyphens), try slug endpoint first
  if (/^[a-z0-9-]+$/.test(slugOrId)) {
    try {
      return await fetchMangaBySlug(slugOrId);
    } catch {
      // Fall back to ID lookup
    }
  }

  // Original ID-based lookup
  const response = await fetch(`${API_BASE_URL}/api/manga/${slugOrId}`);
  if (!response.ok) throw new Error(`HTTP ${response.status}`);
  return response.json();
}
```

**File**: `src/app/(app)/manga/[slug]/page.tsx`

No changes needed - already uses dynamic `slug` param!

**File**: Component link updates

Update all `Link` components to use slugs:

```tsx
// Before:
<Link href={`/manga/${manga.id}`}>

// After:
<Link href={`/manga/${manga.slug || manga.id}`}>
```

### 6. Reading Progress Migration

**File**: `packages/catalog-db/src/migrations.ts`

Reading progress uses `manga_id` which must remain stable (the ID, not slug):

```typescript
// No migration needed - reading_progress.manga_id stays as ID
// Slugs are purely for routing/display
```

## Migration Strategy

### Phase 1: Additive Changes (Non-Breaking)
1. Add `slug` field to SDK types (optional)
2. Add database migration for slug column
3. Update WeebCentral extension to populate slugs
4. Add slug-based API endpoint alongside existing ID endpoint

### Phase 2: Frontend Adoption
1. Update `fetchMangaDetails()` to try slug first
2. Update all Link components to prefer slugs
3. Test both slug and ID access work

### Phase 3: Cleanup (Optional)
1. Monitor which manga have slugs vs IDs
2. Consider requiring slugs for new extensions
3. Keep ID-based access for backward compatibility

## Backward Compatibility

- **Reading Progress**: Uses stable IDs, unaffected
- **Existing Links**: ID-based URLs continue to work via fallback
- **Old Extensions**: Can continue using IDs only (slug optional)
- **Database**: IDs remain primary key, slugs are indexed separately

## Testing Checklist

- [ ] WeebCentral extension populates slugs correctly
- [ ] Database migration runs successfully
- [ ] Slug-based routing works: `/manga/one-piece`
- [ ] ID-based routing still works: `/manga/01J76XY7E9FNDZ1DBBM6PBJPFK`
- [ ] Reading progress unaffected by slug changes
- [ ] Search results link to slug URLs
- [ ] Duplicate slug handling (if two extensions provide same slug)

## Edge Cases

### Duplicate Slugs
If multiple manga have the same slug (e.g., from different extensions):

**Solution**: Scope slugs by extension:
- Database: `UNIQUE (extension_id, slug)`
- URLs: `/manga/{extension-id}:{slug}` or `/manga/{slug}?ext={id}`

**Alternative**: Use slug + ID fallback for collisions

### Slug Changes
If a source renames a series:

**Solution**: Keep original slug stable
- Store slug separately from series_name
- Only update on explicit request or first-time population

## Timeline Estimate

- **Extension Changes**: 1-2 hours
- **Database Migration**: 30 minutes
- **API Endpoint**: 1 hour
- **Frontend Updates**: 2-3 hours
- **Testing**: 2 hours

**Total**: ~8-10 hours of development
